# Default values for netobserv

replicaCount: 1

# The update strategy to apply to the Deployment.
# Available options are: RollingUpdate and Recreate.
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0

image:
  repository: elastiflow/flow-collector
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

env:
  - name: EF_LICENSE_ACCEPTED
    value: 'true'
  # Additional information for available environment variables can be found via
  # the ElastiFlow documentation: https://docs.elastiflow.com/docs/config_ref

# The ElasticSearch output can be used to send records to an ElasticSearch cluster.
# https://docs.elastiflow.com/docs/config_ref/common/output_elasticsearch
outputElasticSearch:
  # Enable/disable the use of the ElasticSearch output.
  enable: false
  # ElasticSearch addresses, comma-separated node:port pairs.
  addresses: ""
  username: elastic
  # It is highly not recommended to set password directly in helm values, but using a credentials management process.
  # Password will be set in secret if defined.
  # password: ""
  # Create or not the secret for ElasticSearch
  secretCreate: true
  # Secret name to be used for the ElasticSearch credentials, `${netobserv.fullname}-es-creds` if undefined
  # secretName: "es-credentials"
  # The key in the kubernetes secret that contains the ElasticSearch user.
  secretKeyUser: username
  # The key in the kubernetes secret that contains the ElasticSearch password.
  secretKeyPassword: password
  tls:
    # Enable/disable TLS connections to ElasticSearch.
    enable: false
    skipVerification: false
    # The name of the config map that contains the CA certificate. If empty, will not be mounted.
    caConfigMapName: ""
    # The key in the config map that contains the CA certificate.
    caConfigMapKey: "ca.crt"
    # The path to the CA certificate file.
    caMountPath: ""
    # The name of the file that contains the CA certificate.
    caFileName: "ca.crt"
  ecs:
    # Enable/disable the use of the Elastic Common Schema (ECS).
    enable: false

  # Provision or not the ElasticSearch Kibana dashboards in the ElasticSearch cluster
  # https://www.elastiflow.com/docs/data_platforms/elastic/kibana/
  # Uses ElasticSearch username/password from the secret
  dashboards:
    provision: false
    url: 'https://raw.githubusercontent.com/elastiflow/elastiflow_for_elasticsearch/master/kibana/flow/kibana-8.14.x-flow-codex.ndjson'
    kibana_url: "http://localhost:5601"
    override: false
    tls:
      validate_certs: false

# The OpenSearch output can be used to send records to an OpenSearch cluster.
# https://docs.elastiflow.com/docs/config_ref/common/output_opensearch
outputOpenSearch:
  # Enable/disable the use of the OpenSearch output.
  enable: false
  # OpenSearch addresses, comma-separated node:port pairs.
  addresses: ""
  username: admin
  # Password will be set in secret if defined.
  # It is highly not recommended to set password directly in helm values, but using a credentials management process.
  # password: ""
  # Create or not the secret for OpenSearch
  secretCreate: true
  # Secret name to be used for the OpenSearch credentials, `${netobserv.fullname}-os-creds` if undefined
  # secretName: "os-credentials"
  # The key in the kubernetes secret that contains the OpenSearch user.
  secretKeyUser: username
  # The key in the kubernetes secret that contains the OpenSearch password.
  secretKeyPassword: password
  tls:
    # Enable/disable TLS connections to OpenSearch.
    enable: false
    skipVerification: false
    # The name of the config map that contains the CA certificate. If empty, will not be mounted.
    caConfigMapName: ""
    # The key in the config map that contains the CA certificate.
    caConfigMapKey: "ca.crt"
    # The path to the CA certificate file.
    caMountPath: ""
    # The name of the file that contains the CA certificate.
    caFileName: "ca.crt"
  ecs:
    # Enable/disable the use of the Elastic Common Schema (ECS).
    enable: false

  # Provision or not the OpenSearch Dashboards dashboards in the OpenSearch cluster
  # https://www.elastiflow.com/docs/data_platforms/opensearch/dashboards/
  # Uses OpenSearch username/password from the secret
  dashboards:
    provision: false
    # Dashboards source URL
    url: 'https://raw.githubusercontent.com/elastiflow/elastiflow_for_opensearch/main/dashboards/flow/dashboards-2.14.x-flow-codex.ndjson'
    # OpenSearch Dashboards address with port (address:port)
    dashboards_url: "http://localhost:5601"
    override: false
    tls:
      validate_certs: false

# The Kafka output can be used to send records to Apache Kafka, Confluent Platform,
# Confluent Cloud, Redpanda and Amazon Managed Streaming for Apache Kafka (Amazon MSK).
# https://docs.elastiflow.com/docs/output-kafka
outputKafka:
  # Enable/disable the use of the Kafka output.
  enable: false
  # A comma-separated list of brokers, IP address and port number, to which the collector is to connect.
  # Example: "192.0.2.11:9092,192.0.2.12:9092,192.0.2.13:9092"
  brokers: ""
  tls:
    # Enable/disable TLS connections to Kafka.
    enable: false
    # The name of the config map that contains the CA certificate. If empty, will not be mounted.
    caConfigMapName: ""
    # The key in the config map that contains the CA certificate.
    caConfigMapKey: "ca.crt"
    # The path to the CA certificate file.
    caMountPath: ""
    # The name of the file that contains the CA certificate.
    caFileName: "ca.crt"

license:
  # Specifies whether a secret should be created. If you don't have a license, no need to create a license secret.
  createSecret: false
  # Secret name to be used for the license. If empty, the secret name defaults to `netobserv-license`
  # If no secret with a matching name exists, the value will be set from `licenseKey` instead.
  secretName: "netobserv-license"
  # Set account ID
  accountId: ""
  # Set license key, if not set, value from secret will be used.
  # It is discouraged to store the license key in the values file. Consider
  # using --set when installing the chart instead of setting the value here.
  licenseKey: ""

# If the EF_PROCESSOR_ENRICH_IPADDR_MAXMIND_ASN_ENABLE or EF_PROCESSOR_ENRICH_IPADDR_MAXMIND_GEOIP_ENABLE
# environment variables are set to true, enable the corresponding service and provide a MaxMind account ID and license key:
# https://dev.maxmind.com/geoip/geolite2-free-geolocation-data
maxmind:
  # Specifies whether a secret should be created for the MaxMind license key.
  createSecret: false
  # Secret name to be used for the license. If empty, the secret name defaults to `maxmind-license`
  # If no secret with a matching name exists, the value will be set from `licenseKey` instead.
  secretName: "maxmind-license"
  # Enabling ASN will look up the autonomous system number and autonomous system
  # organization associated with IPv4 and IPv6 addresses.
  asnEnabled: false
  # Enabling GeoIP will look up the country, subdivisions (regions), city, and
  # postal code associated with IPv4 and IPv6 addresses.
  geoipEnabled: false
  # When GeoIP is enabled, this specifies the frequency in hours to update the MaxMind GeoIP database.
  geoipUpdateFrequency: 24
  accountId: ""
  licenseKey: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: false
  # Automatically mount a ServiceAccount's API credentials?
  automount: false
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# global common labels, applied to all ressources
commonLabels: {}

podAnnotations: {}
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# The netobserv container's ports to expose.
ports:
  - name: api
    containerPort: 8080
    protocol: TCP
  - name: netflow
    containerPort: 9995
    protocol: UDP
  # - name: ipfix
  #   containerPort: 4739
  #   protocol: UDP
  # - name: sflow
  #   containerPort: 6343
  #   protocol: UDP


service:
  annotations: {}
  # The type of service to create. Available options are ClusterIP (default), NodePort, and LoadBalancer.
  type: ClusterIP

  # When the service type is LoadBalancer, the externalTrafficPolicy field routes external traffic to either node-local or cluster-wide endpoints. The two options are:
  # Cluster (default): Obscures the client source IP, may cause a second hop to another node, but ensures good load-spreading.
  # Local: Preserves the client source IP, avoids a second hop for LoadBalancer and NodePort Services, but may lead to imbalanced traffic spreading.
  # externalTrafficPolicy: Cluster

  # When the service type is LoadBalancer, the loadBalancerIP field assigns a static IP address to the service.
  # loadBalancerIP: "35.243.208.106"

  # When the service type is LoadBalancer, the loadBalancerSourceRanges field restricts access to the service from a limited set of IP ranges.
  # loadBalancerSourceRanges:
  #   - "0.0.0.0/0"

  ports:
    - name: api
      port: 8080
      targetPort: 8080
      protocol: TCP
    - name: netflow
      port: 9995
      targetPort: 9995
      protocol: UDP
    # - name: ipfix
    #   port: 4739
    #   targetPort: 4739
    #   protocol: UDP
    # - name: sflow
    #   port: 6343
    #   targetPort: 6343
    #   protocol: UDP

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  defaultBackend:
    service:
      port:
        name: api
  # Use `hosts` to customize routing.
  # hosts:
  #   - # host: chart-example.local # Uncomment if you have a DNS name for the ingress (Load Balancer)
  #     paths:
  #       - path: /api/*
  #         pathType: ImplementationSpecific
  #         backend:
  #           service:
  #             port:
  #               name: api
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

gateway:
  enabled: false
  apiVersion: gateway.networking.k8s.io/v1
  className: ""
  annotations: {}
  listeners:
    - name: http
      port: 80
      protocol: HTTP
      allowedRoutes:
        kinds:
          - kind: HTTPRoute
  # Optionally set the Gateway address
  # addresses:
  #   - type: NamedAddress
  #     value: MyFamousIP
  # Default hostnames to be used in all HTTPRoute resources, can be overridden by individual httpRoutes[].hostnames
  # defaultHostNames: [chart-example.local]
  # HTTPRoutes to be provisioned with the Gateway
  httpRoutes:
    - name: main
      # hostnames: ["foo.bar.com"] # Overrides the gateway.defaultHostNames
      rules:
        - matches:
            - path:
                value: /
          backendRefs:
            - name: '{{ include "netobserv.fullname" $ }}'
              port: 8080
  # GRPCRoutes to be provisioned with the Gateway
  # grpcRoutes:
  #   - name: api
  #     # hostnames: ["foo.bar.com"] # Overrides the gateway.defaultHostNames
  #     rules:
  #       - matches:
  #         - type: Exact
  #           method:
  #           service: "foo"
  #           headers:
  #         backendRefs:
  #           - name: '{{ include "netobserv.fullname" $ }}'
  #             port: 8080

resources:
  limits:
    cpu: "2000m"
    memory: 6144Mi
  requests:
    cpu: "1000m"
    memory: 6144Mi

startupProbe:
  enabled: true
  initialDelaySeconds: 120
  failureThreshold: 10
  httpGet:
    path: /readyz
    port: 8080
livenessProbe:
  enabled: true
  httpGet:
    path: /livez
    port: 8080
readinessProbe:
  enabled: true
  httpGet:
    path: /readyz
    port: 8080

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 2
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          averageUtilization: 80
          type: Utilization
    # - type: Resource
    #   resource:
    #     name: memory
    #     targetAverageUtilization: 80
  # behavior:
  #   scaleUp:
  #     stabilizationWindowSeconds: 300
  #     policies:
  #       - type: Percent
  #         value: 100
  #         periodSeconds: 15
  #   scaleDown:
  #     stabilizationWindowSeconds: 300
  #     policies:
  #       - type: Percent
  #         value: 10
  #         periodSeconds: 15

pdb:
  minAvailable: 10%
  # mutually exclusive setting with "minAvailable"
  # maxUnavailable: 10%

tolerations: []
affinity: {}
topologySpreadConstraints: []

extraVolumes: []
  # - name: example
  #   emptyDir: {}
  # - name: storage-volume
  #   persistentVolumeClaim:
  #     claimName: example

extraVolumeMounts: []
  # - name: example
  #   mountPath: /example
  # - name: storage-volume
  #   mountPath: /data
  #   subPath: ""
  #   readOnly: true

# Prometheus Operator ServiceMonitor
serviceMonitor:
  enabled: false
  # Create the ServiceMonitor in a specific namespace (defaults to release namespace when empty)
  namespace: ""
  # Extra labels to add to the ServiceMonitor (e.g., release: prometheus)
  labels: {}
  # Select Services to scrape across namespaces
  namespaceSelector:
    # When true, select Services in all namespaces. If true, matchNames is ignored.
    any: false
    # Explicit list of namespaces to match. Defaults to the release namespace when empty and any=false.
    matchNames: []
  # Endpoint settings
  interval: 30s
  scrapeTimeout: 10s
  path: /metrics
  scheme: http
  honorLabels: false
  # Name of the Service port to scrape
  portName: api
  # Optional relabelings
  relabelings: []
  metricRelabelings: []
  # Optional params to append to scrape requests, e.g.:
  # params:
  #   match[]:
  #     - '{job="api"}'
  #   foo:
  #     - bar
  # This will result in a request like: /metrics?match%5B%5D=%7Bjob%3D%22api%22%7D&foo=bar
  params: {}
  # Authentication and TLS
  bearerTokenSecret:
    enabled: false
    name: ""
    key: ""
  tlsConfig:
    enabled: false
    insecureSkipVerify: false
    serverName: ""
    caFile: ""
    certFile: ""
    keyFile: ""
  # Limits and labeling
  jobLabel: ""
  targetLabels: []
  sampleLimit: 0
  labelLimit: 0
  labelNameLengthLimit: 0
  labelValueLengthLimit: 0
  followRedirects: true
  proxyUrl: ""

# -- Array of extra K8s manifests to deploy
extraObjects: []
  # - apiVersion: secrets-store.csi.x-k8s.io/v1
  #   kind: SecretProviderClass
  #   metadata:
  #     name: {{ include "netobserv.fullname" . }}
  #   spec:
  #     provider: aws
  #     parameters:
  #       objects: |
  #         - objectName: "argocd"
  #           objectType: "secretsmanager"
  #           jmesPath:
  #               - path: "client_id"
  #                 objectAlias: "client_id"
  #               - path: "client_secret"
  #                 objectAlias: "client_secret"
  #     secretObjects:
  #     - data:
  #       - key: client_id
  #         objectName: client_id
  #       - key: client_secret
  #         objectName: client_secret
  #       secretName: argocd-secrets-store
  #       type: Opaque
  #       labels:
  #         app.kubernetes.io/part-of: argocd
  # # https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-configuration#direct_health
  # - |
  #   apiVersion: cloud.google.com/v1
  #   kind: BackendConfig
  #   metadata:
  #     name: '{{ template "opensearch-dashboards.fullname" . }}'
  #   spec:
  #     healthCheck:
  #       checkIntervalSec: 60
  #       unhealthyThreshold: 2
  #       healthyThreshold: 3
  #       port: 5601
  #       type: HTTP
  #       requestPath: /app/login

# OpenSearch chart values (installed as a dependency)
opensearch:
  enabled: false

# OpenSearch Dashboards chart values (installed as a dependency)
opensearch-dashboards:
  enabled: false
